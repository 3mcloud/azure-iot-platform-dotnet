trigger: none

pool:
  vmImage: ubuntu-18.04
variables:
  - template: ../templates/variables-all.yaml
  - name: buildId
    value: build-$(Build.BuildId)
  - name: applicationCode
    value: crsliot
  - name: applicationShortCode
    value: crsl
  - name: environmentCategory
    value: dev
  - name: subscriptionName
    value: 3M-CRSLAD16-BBIoTP-Dev
  - name: aksName
    value: $(applicationCode)-$(aksPartialName)-$(environmentCategory)
  - name: appConfigurationName
    value: $(applicationCode)-$(appConfigurationPartialName)-$(environmentCategory)
  - name: resourceGroupName
    value: $(resourceGroupPartialName)-iot-$(applicationShortCode)-$(environmentCategory)
  - name: storageAccountName
    value: $(applicationCode)$(storageAccountPartialName)$(environmentCategory)
  - name: tableStorageName
    value: pipeline
  - name: tableStoragePartition
    value: test
  - name: tableStorageRowKeyPrefix
    value: "$(buildId):"
  - name: kubernetesNamespaceWasCreatedRowKey
    value: kubernetesNamespaceWasCreated
  - name: mmmIotPlatformServicesHelmChartWasInstalledRowKey
    value: mmmIotPlatformServicesHelmChartWasInstalled
  - name: mmmIotPlatformIngressHelmChartWasInstalledRowKey
    value: mmmIotPlatformIngressHelmChartWasInstalled
  - name: tableStorageAppConfigurationConnectionStringRowKey
    value: appConfigurationConnectionString
  - name: kubernetesNamespace
    value: $(buildId)
  - name: dockerfile
    value: Dockerfile
  - name: mmmIotPlatformServicesHelmChartName
    value: mmm-iot-platform-services
  - name: mmmIotPlatformIngressHelmChartName
    value: mmm-iot-platform-ingress
  - name: publishedFilesArtifactName
    value: publishFiles
  - name: functionsArtifactName
    value: functionsFiles
  - name: webuiArtifactName
    value: webuiFiles
  - name: helmInstallTimeoutInSeconds
    value: 1000
  - name: mmmIotPlatformServicesHelmChartValuesFile
    value: pipelines/ci/mmm-iot-platform-chart-values.yaml
  - name: mmmIotPlatformServicesHelmChartReleaseName
    value: services-$(buildId)
  - name: mmmIotPlatformIngressHelmChartReleaseName
    value: ingress-$(buildId)
  - name: serenityDevTenantId
    value: 01881b16-2c18-49b5-b6c0-645a30866896
  - name: testPipelineDomain
    value: iot.cld.3m.com
  - name: testPipelineFqdn
    value: $(buildId).$(testPipelineDomain)
  - name: tagsFile
    value: pipelines/cd/arm/tagging/IoT_CRSL_Environment_Dev.json
  - name: authenticationCallbackUrl
    value: https://$(testPipelineFqdn)/auth/connect/callback
  - name: azureAdB2cAppRegistrationTenantId
    value: aaf9651a-6274-4039-8020-6578ad0d9261
  - name: azureAdB2cAppRegistrationNameProd
    value: iotplatform
  - name: azureAdB2cAppRegistrationClientIdProd
    value: 086c6072-f6fe-449f-887c-e08c598aec0b
  - name: azureAdB2cAppRegistrationNameTest
    value: iotplatform-build-test
  - name: azureAdB2cAppRegistrationClientIdTest
    value: 0c1d6d57-adc2-4d44-abd6-d1927516288d
  - name: azureAdB2cTenantUsername
    value: pipeline-nonprod@crsltestab2c.onmicrosoft.com
  - name: dependenciesReportArtifactName
    value: dependenciesReport
  - name: commitsSinceLastReleaseArtifactName
    value: commitsSinceLastRelease
  - name: testResultFileExists
    value: false
  - name: testAccountAdmin
    value: a05e1a04-31bf-4219-9c1b-b7fa7bfedbfc
  - name: testAccountUser
    value: 9745b86e-c1b1-481a-8628-7db8dfaeedf6
  - name: testAccountSysAdmin
    value: b013febd-466d-4694-8f0d-c151ad32023b
  - name: usersTableName
    value: user
  - name: sysAdminTableName
    value: SystemAdmin    
resources:
  repositories:
    - repository: azure-iot-functional-tests
      name: MMM/azure-iot-functional-tests
      type: githubenterprise
      endpoint: MMMGithub
      ref: master
stages:
  - stage: build
    displayName: Build
    dependsOn: []
    jobs:
      - job: preBuild
        displayName: Pre-build
        steps:
          - checkout: none

          - task: AzureCLI@2
            displayName: Get App Configuration connection string
            name: getAppConfigurationConnectionString
            inputs:
              azureSubscription: $(subscriptionName)
              scriptType: pscore
              scriptLocation: inlineScript
              inlineScript: |-
                $appConfigurationConnectionString = az appconfig credential list --name $(appConfigurationName) --resource-group $(resourceGroupName) --query "[?name=='Primary'].connectionString | [0]" --output tsv
                echo "##vso[task.setvariable variable=AppConfigurationConnectionString;isOutput=true]$appConfigurationConnectionString"
                $tableExists = az storage table exists --name $(tableStorageName) --account-name $(storageAccountName) --output tsv
                if ($tableExists -eq $False)
                {
                  az storage table create --name $(tableStorageName) --account-name $(storageAccountName)
                }

                az storage entity insert --entity PartitionKey=$(tableStoragePartition) RowKey=$(tableStorageRowKeyPrefix)$(tableStorageAppConfigurationConnectionStringRowKey) Content="$appConfigurationConnectionString" --table-name $(tableStorageName) --account-name $(storageAccountName)

      - job: build
        displayName: Build Services
        dependsOn:
          - preBuild
        variables:
          AppConfigurationConnectionString: $[dependencies.preBuild.outputs['getAppConfigurationConnectionString.appConfigurationConnectionString']]
        steps:
          - checkout: self
            displayName: Checkout repository

          - script: >-
              dotnet restore
              --force
              --no-cache
              --no-dependencies
              --packages .nuget
              --runtime $(dotnetProductionRuntimeId)
            displayName: Restore dependencies

          - script: >-
              dotnet publish
              --self-contained false
              --no-restore
              --no-dependencies
              --configuration $(dotnetBuildConfiguration)
              --runtime $(dotnetProductionRuntimeId)
              /p:TargetLatestRuntimePatch=true
            displayName: Build assemblies

          - task: CopyFiles@2
            displayName: Prepare services artifacts
            inputs:
              contents: |
                *.sln
                *.props
                *.ruleset
                global.json
                .nuget/**/*
                src/services/**/*
                test/services/**/*
                src/functions/**/*
              targetFolder: $(publishedFilesArtifactName)
              cleanTargetFolder: true


          - publish: $(publishedFilesArtifactName)
            artifact: $(publishedFilesArtifactName)
            displayName: Publish services artifacts


      # - job: functionBuild
      #   displayName: Build Functions
      #   pool:
      #     vmImage: 'vs2017-win2016'
      #   dependsOn:
      #     - preBuild
      #   variables:
      #     AppConfigurationConnectionString: $[dependencies.preBuild.outputs['getAppConfigurationConnectionString.appConfigurationConnectionString']]
      #   steps:
      #     - checkout: self
      #       displayName: Checkout repository

      #     - script: >-
      #         dotnet restore
      #         --force
      #         --no-cache
      #         --no-dependencies
      #         --packages .nuget
      #         /p:TargetLatestRuntimePatch=true
      #       displayName: Restore dependencies

      #     - script: >-
      #         dotnet publish
      #         --self-contained false
      #         --no-restore
      #         --no-dependencies
      #         --configuration $(dotnetBuildConfiguration)
      #         /p:TargetLatestRuntimePatch=true
      #       displayName: Build assemblies

      #     - task: CopyFiles@2
      #       displayName: Prepare Azure Functions artifacts
      #       inputs:
      #         contents: |
      #           src/functions/**/*
      #         targetFolder: $(functionsArtifactName)
      #         cleanTargetFolder: true

      #     - publish: $(functionsArtifactName)
      #       artifact: $(functionsArtifactName)
      #       displayName: Publish Azure Functions artifacts


  # - stage: unitTest
  #   displayName: Unit test
  #   dependsOn:
  #     - build
  #   jobs:
  #     - job: unitTest
  #       displayName: Unit test
  #       variables:
  #         - name: excludeFromCodeCoverage
  #           value: "[Mmm.*.Test*]*%2C[Mmm.*.WebService]*Startup%2C[Mmm.*.WebService]*Program%2C[*]Mmm.Iot.Common.Services.Config.*%2C[*]*DependencyResolution*%2C[*]Mmm.*Model*"
  #       steps:
  #         - checkout: none

  #         - task: DownloadPipelineArtifact@2
  #           displayName: Download artifacts
  #           inputs:
  #             source: current
  #             artifact: $(publishedFilesArtifactName)
  #             path: $(Build.SourcesDirectory)

  #         - task: DotNetCoreCLI@2
  #           displayName: Run unit tests
  #           inputs:
  #             command: test
  #             workingDirectory: $(Build.SourcesDirectory)
  #             arguments: >-
  #               --no-build
  #               --configuration $(dotnetBuildConfiguration)
  #               --runtime $(dotnetProductionRuntimeId)
  #               --logger trx
  #               /p:CollectCoverage=true
  #               /p:CoverletOutputFormat=cobertura
  #               "/p:Exclude=\"$(excludeFromCodeCoverage)\""

  #         - script: |-
  #             dotnet tool install --tool-path ./reportgenerator-tool dotnet-reportgenerator-globaltool
  #             ./reportgenerator-tool/reportgenerator -reports:**/coverage.cobertura.xml -targetdir:. -reporttypes:"Cobertura"
  #           displayName: Generate coverage report

  #         - task: PublishCodeCoverageResults@1
  #           displayName: Publish test coverage
  #           inputs:
  #             codeCoverageTool: Cobertura
  #             summaryFileLocation: Cobertura.xml

  # - stage: buildFrontEndContainers
  #   displayName: Build front-end containers
  #   dependsOn: []
  #   jobs:
  #     - job: lintWebuiCode
  #       displayName: Lint webui code
  #       steps:
  #         - checkout: self
  #           displayName: Checkout repository

  #         - task: NodeTool@0
  #           inputs:
  #             versionSpec: 10.14.1

  #         - pwsh: |-
  #             npm install
  #             npm run lint
  #           displayName: npm run lint
  #           workingDirectory: src/webui

  #         - task: CopyFiles@2
  #           displayName: Prepare services artifacts
  #           inputs:
  #             contents: |
  #               src/webui/**/*
  #             targetFolder: $(webuiArtifactName)
  #             cleanTargetFolder: true

  #         - publish: $(webuiArtifactName)
  #           artifact: $(webuiArtifactName)
  #           displayName: Publish services artifacts

  #     - job: buildFrontEndContainers
  #       displayName: Build front-end containers
  #       dependsOn: []
  #       strategy:
  #         matrix:
  #           reverse-proxy:
  #             serviceName: reverse-proxy
  #           webui:
  #             serviceName: webui
  #       steps:
  #         - checkout: self
  #           displayName: Checkout repository

  #         - task: Docker@2
  #           displayName: Build and push container
  #           inputs:
  #             containerRegistry: $(dockerHubServiceConnectionName)
  #             repository: $(dockerHubRepositoryName)/$(serviceName)
  #             command: buildAndPush
  #             dockerfile: src/$(serviceName)/$(dockerfile)
  #             buildContext: src/$(serviceName)
  #             tags: |-
  #               $(Build.BuildId)
  #               $(Build.SourceVersion)

  - stage: whiteSourceBolt
    displayName: WhiteSource Bolt
    dependsOn:
      - build
    jobs:
      - job: whiteSourceBolt
        displayName: WhiteSource Bolt
        steps:
          - checkout: none
          - task: DownloadPipelineArtifact@2
            displayName: Download service artifacts
            inputs:
              source: current
              artifact: $(publishedFilesArtifactName)
              path: $(Build.SourcesDirectory)/$(publishedFilesArtifactName)

          # - task: DownloadPipelineArtifact@2
          #   displayName: Download functions artifacts
          #   inputs:
          #     source: current
          #     artifact: $(functionsArtifactName)
          #     path: $(Build.SourcesDirectory)/$(functionsArtifactName)

          # - task: DownloadPipelineArtifact@2
          #   displayName: Download webui artifacts
          #   inputs:
          #     source: current
          #     artifact: $(webuiArtifactName)
          #     path: $(Build.SourcesDirectory)/$(webuiArtifactName)
          - task: WhiteSource@21
            inputs:
              cwd: '$(Build.SourcesDirectory)/$(publishedFilesArtifactName)'


  # - stage: listCommitsSinceLastRelease
  #   displayName: List commits since last release
  #   dependsOn: []
  #   jobs:
  #     - job: listCommitsSinceLastRelease
  #       displayName: List commits since last release
  #       steps:
  #         - checkout: self
  #           displayName: Checkout repository

  #         - template: ../templates/print-build-variables.yaml

  #         - template: ../templates/print-agent-variables.yaml

  #         - template: ../templates/print-system-variables.yaml

  #         - template: ../templates/print-common-variables.yaml

  #         - pwsh: |-
  #             if (!(Test-Path $(commitsSinceLastReleaseArtifactName))) {
  #               New-Item $(commitsSinceLastReleaseArtifactName) -Type Directory
  #             }

  #             $previousReleaseTag = git for-each-ref --sort=-creatordate --format '%(tag)' refs/tags | ? {$_.trim() -ne "" } |
  #               Select-Object -First 1
  #             $logFilePath = (Join-Path $(commitsSinceLastReleaseArtifactName) git-log.txt)
  #             "Commits since ${previousReleaseTag}:" | Set-Content $logFilePath
  #             Write-Output "previousReleaseTag: $previousReleaseTag"
  #             Write-Output 'Build.SourceVersion: $(Build.SourceVersion)'
  #             git log --oneline --no-decorate --topo-order ^$previousReleaseTag $(Build.SourceVersion) |
  #               Tee-Object $logFilePath -Append

  #           displayName: List commits since last release

  #         - publish: $(commitsSinceLastReleaseArtifactName)
  #           artifact: $(commitsSinceLastReleaseArtifactName)
  #           displayName: Publish list of commits since last release

  # - stage: microsoftSecurityCodeAnalysis
  #   displayName: Microsoft Security Code Analysis
  #   dependsOn:
  #     - build
  #   jobs:
  #     - job: microsoftSecurityCodeAnalysis
  #       displayName: Microsoft Security Code Analysis
  #       pool:
  #         vmImage: windows-latest
  #       steps:
  #         - checkout: self
  #           displayName: Checkout repository

  #         - task: DownloadPipelineArtifact@2
  #           displayName: Download artifacts
  #           inputs:
  #             source: current
  #             artifact: $(publishedFilesArtifactName)
  #             path: $(Build.SourcesDirectory)

  #         # - task: AntiMalware@3
  #         #   displayName: Scan for malware
  #         #   inputs:
  #         #     InputType: 'Basic'
  #         #     ScanType: 'CustomScan'
  #         #     FileDirPath: '$(Build.SourcesDirectory)'
  #         #     EnableServices: true
  #         #     DisableRemediation: false
  #         #     SupportLogOnError: true
  #         #     TreatSignatureUpdateFailureAs: 'Warning'
  #         #     SignatureFreshness: 'UpToDate'
  #         #     TreatStaleSignatureAs: 'Warning'


  #         - task: MSBuild@1
  #           inputs:
  #             solution: '**/*.sln'
  #             clean: true
  #         - task: RoslynAnalyzers@2
  #           inputs:
  #             userProvideBuildInfo: 'auto'

  #         # - task: BinSkim@3
  #         #   inputs:
  #         #     InputType: 'Basic'
  #         #     Function: 'analyze'
  #         #     AnalyzeTarget: '$(Build.ArtifactStagingDirectory)\src\services\**\*.dll;$(Build.ArtifactStagingDirectory)\src\services\**\*.exe'
  #         #     AnalyzeSymPath: '$(Build.ArtifactStagingDirectory)\**\bin\**\*.pdb'
  #         #     AnalyzeVerbose: true
  #         # - task: CredScan@2
  #         #   displayName: Scan for credentials
  #         #   inputs:
  #         #     toolMajorVersion: 'V2'
  #         #     verboseOutput: true

  #         - task: SdtReport@1
  #           displayName: Generate report
  #           inputs:
  #             AllTools: true
  #             BinSkim: true
  #             BinSkimBreakOn: Error
  #             CredScan: false
  #             MSRD: false
  #             RoslynAnalyzers: false
  #             RoslynAnalyzersBreakOn: Error
  #             TSLint: false
  #             ToolLogsNotFoundAction: Standard

  #         - task: PublishSecurityAnalysisLogs@2
  #           displayName: Publish report
  #           inputs:
  #             ArtifactName: CodeAnalysisLogs
  #             ArtifactType: Container
  #             AllTools: true
  #             ToolLogsNotFoundAction: Standard


  # - stage: cleanup
  #   displayName: Cleanup
  #   condition: and(succeededOrFailed(), eq(variables['runCleanupStage'], 'true'))
  #   jobs:
  #     - job: getPipelineVariables
  #       displayName: Get pipeline variables
  #       dependsOn: []
  #       steps:
  #         - checkout: none

  #         - task: AzureCLI@2
  #           displayName: Get pipeline variables
  #           name: getPipelineVariables
  #           inputs:
  #             azureSubscription: $(subscriptionName)
  #             scriptType: bash
  #             scriptLocation: inlineScript
  #             inlineScript: |-
  #               kubernetesNamespaceWasCreated=`az storage entity query --filter "PartitionKey eq '$(tableStoragePartition)' and RowKey eq '$(tableStorageRowKeyPrefix)$(kubernetesNamespaceWasCreatedRowKey)'" --select Content --query items[].Content --output tsv --table-name $(tableStorageName) --account-name $(storageAccountName)`
  #               echo "##vso[task.setvariable variable=kubernetesNamespaceWasCreated;isOutput=true]$kubernetesNamespaceWasCreated"
  #               mmmIotPlatformServicesHelmChartWasInstalled=`az storage entity query --filter "PartitionKey eq '$(tableStoragePartition)' and RowKey eq '$(tableStorageRowKeyPrefix)$(mmmIotPlatformServicesHelmChartWasInstalledRowKey)'" --select Content --query items[].Content --output tsv --table-name $(tableStorageName) --account-name $(storageAccountName)`
  #               echo "##vso[task.setvariable variable=mmmIotPlatformServicesHelmChartWasInstalled;isOutput=true]$mmmIotPlatformServicesHelmChartWasInstalled"
  #               mmmIotPlatformIngressHelmChartWasInstalled=`az storage entity query --filter "PartitionKey eq '$(tableStoragePartition)' and RowKey eq '$(tableStorageRowKeyPrefix)$(mmmIotPlatformIngressHelmChartWasInstalledRowKey)'" --select Content --query items[].Content --output tsv --table-name $(tableStorageName) --account-name $(storageAccountName)`
  #               echo "##vso[task.setvariable variable=mmmIotPlatformIngressHelmChartWasInstalled;isOutput=true]$mmmIotPlatformIngressHelmChartWasInstalled"

  #     - job: deleteDnsRecordSet
  #       displayName: Delete DNS record set
  #       dependsOn: []
  #       steps:
  #         - checkout: none

  #         - task: AzureCLI@2
  #           displayName: Delete DNS record set
  #           name: deleteDnsRecordSet
  #           inputs:
  #             azureSubscription: $(subscriptionName)
  #             scriptType: pscore
  #             scriptLocation: inlineScript
  #             inlineScript: |-
  #               $recordSetCount = az network dns record-set a list --zone-name $(testPipelineDomain) --resource-group $(resourceGroupName) --query '[?name==`$(buildId)`] | length(@)'
  #               if ($recordSetCount -gt 0) {
  #                 az network dns record-set a delete --name $(buildId) --zone-name $(testPipelineDomain) --resource-group $(resourceGroupName) --yes
  #               }

  #     - job: deleteNamespace
  #       displayName: Delete namespace
  #       dependsOn:
  #         - getPipelineVariables
  #       condition: and(eq(dependencies.getPipelineVariables.outputs['getPipelineVariables.kubernetesNamespaceWasCreated'], 'true'), not(failed()))
  #       steps:
  #         - checkout: none

  #         - task: Kubernetes@1
  #           displayName: Delete namespace
  #           inputs:
  #             connectionType: Azure Resource Manager
  #             azureSubscriptionEndpoint: $(subscriptionName)
  #             azureResourceGroup: $(resourceGroupName)
  #             kubernetesCluster: $(aksName)
  #             command: delete
  #             arguments: namespace $(kubernetesNamespace) --now=true --ignore-not-found=true